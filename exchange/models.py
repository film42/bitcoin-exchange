import inspect

from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.contrib.auth import models as auth_models
from django.contrib.auth.models import AbstractUser
from django_enumfield import enum

from uuidfield import UUIDField


class TradeTypes(enum.Enum):
    MARKET = 0
    LIMIT = 1


class SideTypes(enum.Enum):
    BUY = 0
    SELL = 1


class CurrencyTypes(enum.Enum):
    USD = 0
    BTC = 1


# Can be not filled at all, partially filled, or completely filled
class FilledStatusTypes(enum.Enum):
    NONE = 0
    PARTIAL = 1
    COMPLETE = 2


class BaseModel(models.Model):
    """Abstract base model that all other models should inherit from."""
    created_at = models.DateTimeField('Created at', auto_now_add=True)
    modified_at = models.DateTimeField('Modified at', auto_now=True)

    class Meta:
        abstract = True
        app_label = "exchange"
        verbose_name = _('BaseModel')
        verbose_name_plural = _('BaseModels')


class User(AbstractUser):
    guid = UUIDField(auto=True, hyphenate=True)
    pass


# Is this needed?
auth_models.User = User


class Order(BaseModel):
    user = models.ForeignKey('User')
    order_type = enum.EnumField(TradeTypes)
    guid = UUIDField(auto=True, hyphenate=True)
    side = enum.EnumField(SideTypes)
    amount = models.DecimalField(max_digits=15, decimal_places=8)  # up to 1,000,000
    limit = models.DecimalField(max_digits=13, decimal_places=8)  # up to 10,000
    from_currency = enum.EnumField(CurrencyTypes)
    # it should not be possible for the from currency to equal the to currency
    to_currency = enum.EnumField(CurrencyTypes)
    status = enum.EnumField(FilledStatusTypes, default=FilledStatusTypes.NONE)

    @property
    def order_type_as_string(self):
        if self.order_type == TradeTypes.LIMIT:
            return "Limit"
        else:
            return "Market"

    @property
    def status_as_string(self):
        if self.status == FilledStatusTypes.NONE:
            return "Open"
        elif self.status == FilledStatusTypes.PARTIAL:
            return "Partially Filled"
        else:
            return "Filled"

    @property
    def side_as_string(self):
        if self.side == SideTypes.BUY:
            return "Buy"
        else:
            return "Sell"

    class Meta:
        app_label = "exchange"
        verbose_name = _('Order')
        verbose_name_plural = _('Orders')


# these are generated by exchanges
class Trade(BaseModel):
    # the amount each unit from the buy_order will cost, expressed in terms of the sell currency
    rate = models.DecimalField(max_digits=15, decimal_places=8)  # up to 1,000,000
    guid = UUIDField(auto=True, hyphenate=True)
    buy_order = models.ForeignKey('Order', related_name="buy_order")
    sell_order = models.ForeignKey('Order', related_name="sell_order")
    filled = models.BooleanField(default=False)

    class Meta:
        app_label = "exchange"
        verbose_name = _('Trade')
        verbose_name_plural = _('Trades')


# url where the exchange can be contacted, and base currency that the exchange uses
class Exchange(BaseModel):
    api_url = models.CharField(max_length=255)
    base_currency = enum.EnumField(CurrencyTypes)

    class Meta:
        app_label = "exchange"
        verbose_name = _('Exchange')
        verbose_name_plural = _('Exchanges')


# security supported by exchange
class ExchangeSecurity(BaseModel):
    exchange = models.ForeignKey('Exchange')
    currency_type = enum.EnumField(CurrencyTypes)

    class Meta:
        app_label = "exchange"
        verbose_name = _('ExchangeSecurity')
        verbose_name_plural = _('ExchangeSecurities')


class Account(BaseModel):
    user = models.ForeignKey('User')
    guid = UUIDField(auto=True, hyphenate=True)
    currency_type = enum.EnumField(CurrencyTypes)
    balance = models.DecimalField(max_digits=15, decimal_places=8)

    class Meta:
        app_label = "exchange"
        verbose_name = _('Account')
        verbose_name_plural = _('Accounts')
